\Chapter{Mérések, összehasonlítások}

Ebben a fejezetben megvizsgáljuk a program különböző részeit futás idő szempontjából. Egyes programrészeket ideje konstans az az nem függ az adatok mennyiségétől, így ezek ideje csak a fejezet végén, a gyakorlati példáknál kerülnek feltüntetésre. Első sorban nézzük azokat a részeket amelyek nagyban függnek a táblamérettől vagy az előállítani kívánt kimenettől.  


\Section{Adatok előkészítése}

Itt vizsgáljuk részletesen azt, mennyi idő eljuttatni az adatokat a \texttt{MySQL} szerverről a videokártya puffereibe. Sejteni lehet, hogy a legtöbb értékes időt itt veszíthetjük el.

\SubSection{A MySQL lekérdezés sebessége}
Ezt a sebességet a következő két sor vizsgálatával kaphatjuk meg a legpontosabban:
\begin{python}
pstmt = con->prepareStatement(command);
res = pstmt->executeQuery();
\end{python}
Ahhol \texttt{command} egy \texttt{String} az SQL parancs és a következő módon áll össze:
\begin{python}
range=32768;
    while(i <= 1048576){
    		command = "SELECT * FROM speedtest_1048576 Limit " 
    			+ to_string(i);
    		. . .
   	 	i+=range;
    }
\end{python}
Ezen kívül a grafikonon látható tüskék mértékének csökkentése érdekében minden lekérdezést 5x futtattam és idejüket átlagoltam.
\begin{itemize}
\item A LIMIT hozzáadása a lekérdezéshez nem növeli annak idejét.
\item A tábla tartalmaz elsődleges kulcsot, enélkül a lekérdezések ideje nő.
\item A lekérdendő oszlopokat manuálisan módosítottam a programban. 
\begin{itemize} 
\item \texttt{SELECT c1p1 FROM ...}
\item \texttt{SELECT c1p1, c2 FROM ...} 
\item \texttt{SELECT c1p1, c2, c3 FROM ...} 
\item \texttt{SELECT * FROM ...} 
\end{itemize}
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/sqlquery.png}
\caption{Az SQL lekérdezési sebessége}
\label{fig:schema}
\end{figure}
%BETŰMÉRET NAGYÍTÁSRA SZORUL
Az ábrán, egyértelműen látható, hogy a sorok számának növekedésével az idő is lineárisan nő.
Jelmagyarázatnál látható egyenes egyenletekből becsléseket lehet készíteni adott paraméterekkel rendelkező szűrés nélküli lekérdezéshez. 

Tegyük fel, hogy a négy oszlop felett az időnövekedés lineáris, így több oszlopra egyszerű szorzással megkaphatjuk az időket.

4 és 6 oszlop esetén:
$$ x = \text{sorok száma}/32768 - 1 $$
$$ 7813 * \text{sorok száma} + 7783 = \text{lekérdezés ideje}$$
$$ \text{lekérdezés ideje} * 1.5 = \text{lekérdezés ideje 6 oszlopra} $$


\SubSection{A query válaszának átmásolása a saját tömbbe}
A lekérdezésből kapott választ át kell másolni az általunk létrehozott tömbbe. Ez az egyik legköltségesebb művelet, ezért optimalizálásként célszerű csak a felhasznált oszlopokat lekérni, ez vonatkozik az előző alfejezetre is.
A mért program szakasz:
\begin{python}
int i = 0;
*T1_size = res->rowsCount();
*T1 = (Table1Type*) malloc(sizeof(Table1Type) * *T1_size);

while (res->next())
	{
		T1[0][i].c1p1 = res->getInt("c1p1");
		T1[0][i].c2 = res->getInt("c2");
		T1[0][i].c3 = res->getInt("c3");
		T1[0][i].c4 = res->getInt("c4");
		i++;
	}
delete res;
delete pstmt;
\end{python}

Itt a válaszból lekérdezzük a méretet, majd ez alapján létrehozzuk a saját objektumunkat a memóriában, ezután egyesével belemásoljuk 
a kapott adatokat soronként.
Az mérési módszer megegyezik az előzőekben használtakkal.
A texttt{res} és texttt{pstmt} törlése időméréskor nagyon fontos, ugyanis ennek kihagyása miatt a memória megtelhet!


\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/ccopy.png}
\caption{Adatok másolása saját tömbbe}
\label{fig:schema}
\end{figure}

A grafikonon két dolgot vehetünk észre azonnal. Az egyik az, hogy ez a folyamat lassabb mint maga a lekérdezés a másik pedig, hogy drasztikusabb a növekedés az oszlopok számának sokasodásával.
Tegyük fel, hogy 4 oszlop felett már nincs szignifikáns eltérés az időnövekedésben. Ekkor használhatjuk az előbb is használt módszert a becslésekhez.

Másolás becslése 4 és 6 oszlop esetén:
$$ x = \text{sorok száma}/32768 - 1 $$
$$ 10019 * x + 7692 = \text{másolás ideje}$$
$$ \text{másolás ideje} * 1.5 = \text{másolás ideje 6 oszlopra} $$

\SubSection{Adatok bemásolása a pufferekbe}

Az adatok átmásolása az OpenCL puffereibe szintén egy olyan része a programnak, ami sok időt emészthet fel.
Vizsgált rész:

\begin{python}
int range=65536;
while( range <= 1048576){
 clStatus = clEnqueueWriteBuffer(command_queue, Table1_clmem,
  CL_TRUE, 0, range * sizeof(Table1Type), t1, 0, NULL, NULL);
 clStatus = clEnqueueWriteBuffer(command_queue, Table_size_clmem,
  CL_TRUE, 0, sizeof(int), &t1_size, 0, NULL, NULL);
 clStatus = clEnqueueWriteBuffer(command_queue, Interval_size_clmem,
  CL_TRUE, 0, sizeof(int), &interval_size, 0, NULL, NULL);
 clStatus = clFinish(command_queue);
	range += 65536;
}
\end{python}

A mérés a belső 4 sorra vonatkozik. 

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/inpuffer.png}
\caption{Adatok kimásolása 2.}
\label{fig:schema}
\end{figure}

Mivel ebben az esetben a másolás egybefüggő memória területre vonatkozik, nem pedig elemenkénti hivatkozás, ezért elegendő egyetlen mérés.
A grafikonon egy 4 oszlopos tábla átmásolásának a sebessége látható. Ebből Több vagy kevesebb oszlopra a becslés egyszerű szorzásokkal megkapható.

4 és 3 oszlop esetén:
$$ x = \text{sorok száma} / 65536 $$
$$ 348*x + 452 = \text{pufferbe másolás ideje} $$ 
$$ \text{pufferbe másolás ideje} * 0.75 = \text{3 oszlopos pufferbe másolás ideje}  $$



\SubSection{Adatok kimásolása a pufferekből}

A program ezen részének hatékonysága már egy komplexebb vizsgálatot igényel.
Nézzük az első kiolvasási módszert, amikor a teljes válasz listát illetve a hozzá tartozó számlálót másoljuk ki.
Jelen mérésnél a lista csak egyetlen indexet tartalmaz. 

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/outpuffer.png}
\caption{Adatok kimásolása 2.}
\label{fig:schema}
\end{figure}

$$ 81,2*x + 156 = \text{puffer kiolvasási ideje} $$ 
Az előzőhöz hasonlóan itt is egy memória darabot másolunk, ennek szorzásával megkapjuk mennyi időbe telne a kiolvasás indexpárok vagy számított értékek hozzáadása esetén.
Ne felejtsük el, hogy ehhez tartozik egy számláló, ami jelen esetben a képlethez képest az elemszám gyöke, de két érték esetén már csak a felének a gyöke.
Ez azt jelenti, hogy $2^{20}$ -on érték esetén is a kiolvasási ideje csak megközelítőleg 37$\mu\text{s}$


A másik módszer miszerint nem olvassuk ki azonnal a választ, hanem alkalmazzuk az előző fejezetben taglalt optimalizálási eljárást.
Ennek hatékonysága a sok kisebb olvasás miatt függ az eredmények számától. Ennek méréséhez módosítani kell a kernel kódot, ezért maunálisan végeztem a méréseket, vagyis a szűrési feltételeket úgy módosítottam, hogy a találatok száma megfelelően változzon.
Fontos figyelembe venni, hogy a számok véletlenszerűek a táblázatban.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/outpuffer2.png}
\caption{Adatok kimásolása 2.}
\label{fig:schema}
\end{figure}

Végeredményként látjuk, hogy ez a fajta kiolvasás rendkívül hatékony, de csak abban az esetben, ha a találatok száma minimális.
238 találatnál a módszer elérte azt az időt, ami alatt el lehet végezni a teljes másolást egy darabban.
\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/outpuffer3.png}
\caption{Adatok kimásolása 2.}
\label{fig:schema}
\end{figure}

\newpage
\SubSection{A globális méretből adódó sebességek}

A megfelelő globális méret meghatározása futási idő szempontjából nagyon fontos.

Túl nagy globális méret hatásai:
\begin{itemize}
\item A lokális méret korlátai miatt túl sok csoport jön létre, így azok feldolgozása soros lesz.
\item A kimeneti számláló mérete megnő, ennek kiolvasása több idő, és alacsony találati szám mellett a fölösleges ellenőrzések száma szignifikáns lehet.
\end{itemize}

Túl alacsony globális méret hatásai:
\begin{itemize}
\item A lokális méretet is szükséges lehet csökkenteni. Ha túl alacsony, akkor egyetlen munkaelem fogja végrehajtani, a párhuzamosság teljesen megszűnik.
\item A kimeneti számláló mérete alacsony, kevés visszatérő értéknél a kiolvasás gyors.
\end{itemize}


A méréseket ezen pontok alapján a következők szerint végeztem.

A globális méret változzon 1 - $2^{20}$ értékig, a lokális pedig 1 - 1024 ig négyzetes lépcsőkkel, az oszthatóságra figyelve.

A vizsgált kódrészlet:
\begin{python}  
timer.start();

clStatus = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL, 
	&global_size, &local_size, 0, NULL, NULL);

clStatus =
	clEnqueueReadBuffer(command_queue, Result_indexes_list_clmem, 
	CL_TRUE, 0, global_size* sizeof(int), 
	result_counter, 0, NULL, NULL);
	
clStatus = clEnqueueReadBuffer(command_queue, TableResult_clmem, 
	CL_TRUE, 0, t1_size * sizeof(TableResultType), 
	result  , 0,NULL, NULL);

clStatus = clFinish(command_queue);
clStatus = clFlush(command_queue);

for(int i=0; i<global_size; i++)
{
	for(int j = 0; j < result_counter[i]; j++ )
	{

	}
}
myfile << timer.elapsedMicroseconds() << "," ;  
\end{python}

Szembetűnő lehet az egymásba ágyazott két ciklus. Azért szerepel ez kódrészlet a mérésekbe, hogy az eredményeken való végiglépegetés idejének nagyságrendje valamilyen módon meghatározható legyen. Fontos megjegyezni, hogy a fordítás során nem kerül figyelmen kívül hagyásra ez a két ciklus.

A következő diagrammon látható részletesen mely program szakasz mennyi időbe telik.
Minden esetben a Lokális méret 32 és a visszatérő értékek száma körülbelül $50\%$. Az eredményben csak index szerepel.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/gantt.png}
\caption{Programszakaszok ideje.}
\label{fig:schema}
\end{figure}

Látható, hogy a túl alacsony globális méret túl magas kernel futási időt eredményez. Túl nagy méret esetében pedig az eredmények kezelésének ideje válik számításigényessé.

\newpage

Az eredményt megvizsgálva látható, hogy van egy optimális globális méret tartomány $262144$ és $1024$ között.
Azt is észrevehetjük, hogy bizonyos lokális méretek ebben a tartományban drasztikusan rosszabb eredményt mutatnak.
A 16 és 32 -es méretek állnak legközelebb az ideális futási időhöz.
\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/gs_1_max.png}
\caption{Maximális találat, az eredmény csak index.}
\label{fig:schema}
\end{figure}


A második grafikonon egy olyan mérés látható, ahol a kernelben található feltételt úgy állítottam be, hogy megközelítőleg csak a tábla méretének 10\% -ával térjen vissza a lekérdezés.
Azt láthatjuk, hogy az előző középen lévő hullám lesimul, ez részben annak köszönhető hogy a kernel futási ideje csökken azzal, hogy nem kell annyi indexet az eredmény tömbbe írnia.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/gs_1_10.png}
\caption{kb. 10\% találat, az eredmény csak index.}
\label{fig:schema}
\end{figure}

Azoknál a lekérdezéseknél, a kernelnek nem csak egy indexel kell visszatérnie hanem több kalkulált értékkel is, ott is hasonló grafikonokat kapunk. De a kernel növekvő munkája és a megnövekedett adatmennyiség kiolvasása miatt a középen lévő hullám nagyobb és nehezebben lapul le.

Ezek alapján meghatározható, hogy az 
\newpage
\Section{Gyakorlati példák és következtetések}

A hatékonyság megállapításához a \texttt{A MySQL lekérdezés sebessége} részben használt módszert fogom alkalmazni.
A fejezetben előfordulnak rövidítések: CONN - a MySQL Connector programra a CL pedig az OpenCL -t használó programra utal. 
A k betű ezres szorzót, az i betű pedig indexelés használatot jelöl.

Bontsuk az \texttt{OpenCL} programot négy részre:
\begin{itemize}
\item Előkészítés - Minden ami a kernel futása előtt történik.
\item Kernel(ek) futása
\item Eredmények kiolvasása
\item Eredmények kezelése
\end{itemize}
A \texttt{Connector} programot pedig 3 részre
\begin{itemize}
\item Előkészítés - Minden ami a kernel futása előtt történik.
\item Lekérdezés - A korában már említett két sor
\item Eredmények kezelése
\end{itemize}
Az eredmény kezelése résznél azt vizsgáljuk melyik esetben gyorsabb az eredményeket fájlba írni.
\newpage
\SubSection{Egy táblás lekérdezés}

\begin{python}
SELECT * FROM speedtest_1048576 WHERE c3 = 1 AND c4 > 5001;
	5307 row(s) returned
SELECT * FROM speedtest_1048576 WHERE c3 > 1 AND c4 > 5001;
	514025 row(s) returned
\end{python}
Először vizsgáljuk meg azt, mennyi ideig tart a lekérdezés, ha a Connenctor -t használjuk.

\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}
\hline
Sorok száma & 5307 & 514025 \\
\hline\hline

Előkészítés & 21237 $\mu s$ & 19125 $\mu s$ \\
\hline

Lekérdezés & 183674 $\mu s$ & 273130 $\mu s$ \\
\hline

Eredmény kiírás & 12591 $\mu s$ & 1110877 $\mu s$ \\
\hline
\end{tabular}
\end{table}
Ugyan ez indexeléssel:
\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}
\hline
Sorok száma & 5307 & 514025 \\
\hline
\hline

Előkészítés & 21483 $\mu s$ & 16573 $\mu s$ \\
\hline

Lekérdezés & 23979 $\mu s$ & 268184 $\mu s$ \\
\hline

Eredmény kiírás & 17009 $\mu s$ & 1087573 $\mu s$ \\
\hline
\end{tabular}
\end{table}

Illetve az \texttt{OpenCL} program használatakor:
\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}
\hline
Sorok száma & 5307 & 514025 \\
\hline
\hline
Előkészítés & 688786 $\mu s$ & 685148 $\mu s$ \\
\hline
Kernel futás & 1851 $\mu s$ & 2314 $\mu s$ \\
\hline
Eredmény kiolvasás & 2107 $\mu s$ & 2034 $\mu s$ \\
\hline
Eredmény kiírás & 11682 $\mu s$ & 929053 $\mu s$ \\
\hline

\end{tabular}
\end{table}

Láthatjuk, hogy összességében az OpenCL megvalósítás sokkal lassabb. De vegyük észre, hogy a program legtöbb részének csak egyszer kell lefutnia. 
Több lekérdezés végezhető úgy, hogy csak a  kernel és eredménykiolvasás idejét kell többszörözni. Ezen kívül feltűnhet azt is, hogy a tömbben lévő adatokat kiírás szempontjából gyorsabban lehet kezelni.

Ne feledjük azt sem, hogy a táblát utólag indexelni körülbelül 5,5 másodperce telt!

A hatékonyságot a következő módon becsülhetjük:
\begin{itemize}
\item Az előkészítést egyszer vesszük figyelembe.
\item Az előkészítési időhöz hozzá adjuk az ismétlődő részeket.

Lekérdezés, kernel(ek) futása, eredmény kiolvasás, eredmény kiírás.

\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/test/where.png}
\caption{Becslés csak a lekérdezésre.}
\label{fig:schema}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/test/where_write.png}
\caption{Becslés az eredmények kiírásával.}
\label{fig:schema}
\end{figure}

A mérésekből a következő következtetéseket vonhatjuk le:
0.5\% os visszatérési arany esetében ha nincs indexelés, akkor 7 lekérdezés után megtérülhet az adatok mozgatási költsége.
Ha van indexelés akkor ez a szám eléri a 37 -et.
50\% -os visszatérési aránynál már a 2. lekérdezésnél is nyereséges az \texttt{OpenCL} -es megvalósítás. 

A grafikonon a \texttt{CONN 500k} és \texttt{CONN500k i} szinte egymást fedi, amiből látjuk, hogy ha a válaszban visszatérő sorok száma magas, akkor az indexelés hatékonysága alacsony.


\newpage
\SubSection{Két táblás lekérdezés}

\begin{python}
SELECT TM.c1p1, TS.c1p1, TM.c3*TS.c3 FROM speed2.speed_262144 AS TM 
JOIN speed2.speed_131072 AS TS ON (TM.fk_s = TS.c1p1) 
WHERE TM.c3>9600 AND TS.c3>9200; 
	839 row(s) returned
WHERE TM.c3>9900 AND TS.c3>9900; 
	16 row(s) returned
\end{python}

Az \texttt{Connector} mérései.

\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}
\hline
Sorok száma & 16 & 839 \\
\hline\hline

Előkészítés & 21425 $\mu s$ & 21893 $\mu s$ \\
\hline

Lekérdezés & 39363 $\mu s$ & 85889 $\mu s$ \\
\hline

Eredmény kiírás & 90 $\mu s$ & 2120 $\mu s$ \\
\hline

\end{tabular}
\end{table}

Indexeléssel:
\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}
\hline
Sorok száma & 16 & 839 \\
\hline
\hline

Előkészítés & 20984 $\mu s$ & 26650 $\mu s$ \\
\hline

Lekérdezés & 10119 $\mu s$ & 31663 $\mu s$ \\
\hline

Eredmény kiírás & 97 $\mu s$ & 2802 $\mu s$ \\
\hline

\end{tabular}
\end{table}

OpenCL megvalósítás

\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}
\hline
Sorok száma & 16 & 839 \\
\hline
\hline
Előkészítés & 333354 $\mu s$ & 329314 $\mu s$ \\
\hline
Kernel 1. 2. futása & 556 $\mu s$ & 561 $\mu s$ \\
\hline
Kernel 3. futása & 6912 $\mu s$ & 112407 $\mu s$ \\
\hline
Eredmény kiolvasás & 1842 $\mu s$ & 1962 $\mu s$ \\
\hline
Eredmény kiírás & 131 $\mu s$ & 1796 $\mu s$ \\
\hline
\end{tabular}
\end{table}	

Az \texttt{OpenCL} -es futási időket továbbá azzal igyekeztem optimalizálni, hogy a szerverről csak a szükséges oszlopokat kértem le, így elkerülve a fölösleges adatok mozgatását.

\newpage
\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/test/join.png}
\caption{Becslés csak a lekérdezésre.}
\label{fig:schema}
\end{figure}

A méréseket látva, arra következtetésre juthatunk, hogy az \texttt{OpenCL} kód nem bizonyul hatékonynak, még ilyen alacsony találati számnál sem. A kiolvasási időt tovább lehetne optimalizálni az előzőekben említett másik módszerrel, ezzel akár tizedére is csökkenhet a kiolvasási idő, illetve minimálisan javulhat a kiírási idő is. Ez a kis számú lekérdezés annyira speciális esete lenne a lekérdezéseknek, hogy nem vizsgálom tovább.

A táblakapcsolás nélküli lekérdezéshez képesti drámai teljesítmény romlás oka az hogy a \texttt{MySQL} motorja a táblák kapcsolásánál felhasználja a másodlagos kulcsokat mint index így nem kell végignéznie a táblát a párokat keresve.

Valamilyen indexelési módszer használatával az \texttt{OpenCL} megvalósítás is optimalizálható lenne, ám ez bonyolult és költséges lehet.

Az ábrán jól látható, hogy már 839 visszatérő sornál is a CL megvalósítás a leglassabb. A 16 soros lekérdezés pedig alig előzi meg az indexelt lekérdezést.
Az eredményekből azt is látjuk, hogy nagyobb mértékben nőtt a futási ideje a CL programnak, azaz még több visszatérő sor eseten a módszer még kevésbé hatékony.



%-Mysql nagyon hatékony
%- Főleg ha kevéssel tér vissza és van index ésvagy join

%- HDD lassabb lehet.
%- Jobb videókártya lasabb CPU

%- Globálisba dolgozunk de cache lenne jó


