const char *saxpy_kernel =

    "typedef struct{                              \n"
    " float a;                                    \n"
    "}myfloat;                                    \n"
    "__kernel                                   \n"
    "void saxpy_kernel(float alpha,             \n"
    "                  __global myfloat *A,       \n"
    "                  __global float *B,       \n"
    "                  __global myfloat *C)       \n"
    "{                                          \n"
    "    //Get the index of the work-item       \n"
    "    int index = get_global_id(0);          \n"
    "    C[index].a = alpha* A[index].a + B[index]; \n"
    "}                                          \n";



const char *t3tovramKernel =
"typedef struct {  \n"
"  int c1p3;        \n"
"  int c2;        \n"
"  int c3;        \n"
"  int c4;        \n"
"  int fk_p1_p3;        \n"
"  int fk_p2_p3;        \n"
"} Table3Type;        \n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#define LOCK(a) atom_cmpxchg(a, 0, 1)\n"
"#define UNLOCK(a) atom_xchg(a, 0)\n"
"__kernel                                   \n"
"void t3tovramKernel(                             \n"
"                  __global Table3Type *A,          \n"
"                  __global Table3Type *B,          \n"
"                   __global int *counter,          \n"
"                     __global int *mutex)         \n"
"{                                          \n"
"                           \n"
"    //Get the index of the work-item       \n"
"    int index = get_global_id(0);          \n"
"    if(A[index].c3>9999) {                 \n"
"     while(LOCK(mutex));                   \n"
"     int a = index;                  \n"
"    B[*counter].c1p3 = A[a ].c1p3;      \n"
"    B[*counter].c2 = A[a ].c2;           \n"
"    B[*counter].c3 = A[a ].c3;           \n"
"    B[*counter].c4 = A[a ].c4;           \n"
"    B[*counter].fk_p1_p3 = A[a ].fk_p1_p3;      \n"
"    B[*counter].fk_p2_p3 = A[a ].fk_p2_p3;      \n"
"    atomic_inc(counter);\n"
"    UNLOCK(mutex);     \n"       
"  }           \n"
"}                                          \n";


const char *komplex1Kernel =
"typedef struct {  \n"
"  int c1p3;        \n"
"  int c2;        \n"
"  int c3;        \n"
"  int c4;        \n"
"  int fk_p1_p3;        \n"
"  int fk_p2_p3;        \n"
"} Table3Type;        \n"
"typedef struct {  \n"
"  int c1p2;        \n"
"  int c2;        \n"
"  int c3;        \n"
"  int fk_p1_p2;        \n"
"} Table3Type;        \n"
"typedef struct {  \n"
"  int c1p2;        \n"
"  int c1p3;        \n"
"} ReturnedTable;        \n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#define LOCK(a) atom_cmpxchg(a, 0, 1)\n"
"#define UNLOCK(a) atom_xchg(a, 0)\n"
"__kernel                                   \n"
"void t3tovramKernel(                             \n"
"                  __global Table3Type *A,          \n"
"                  __global Table3Type *B,          \n"
"                   __global int *counter,          \n"
"                     __global int *mutex)         \n"
"{                                          \n"
"                           \n"
"    //Get the index of the work-item       \n"
"    int index = get_global_id(0);          \n"
"    if(A[index].c3>9999) {                 \n"
"     while(LOCK(mutex));                   \n"
"     int a = index;                  \n"
"    B[*counter].c1p3 = A[a ].c1p3;      \n"
"    B[*counter].c2 = A[a ].c2;           \n"
"    B[*counter].c3 = A[a ].c3;           \n"
"    B[*counter].c4 = A[a ].c4;           \n"
"    B[*counter].fk_p1_p3 = A[a ].fk_p1_p3;      \n"
"    B[*counter].fk_p2_p3 = A[a ].fk_p2_p3;      \n"
"    atomic_inc(counter);\n"
"    UNLOCK(mutex);     \n"       
"  }           \n"
"}                                          \n";